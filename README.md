# Методические указания по выполнению курсового проекта по дисциплине ПОСРВ

## Реализация, оформление исходного кода веб-приложения

### 1. Введение
#### 1.1.
  Систематическое необоснованное нарушение правил оформления исходного кода является признаком низкой квалификации разработчика.
#### 1.2.
  Правила не являются панацеей от написания плохого кода.
###  2. Организация проекта
#### 2.1.
  В общем случае файл должен содержать объявление одного класса. Возможно объявление нескольких вспомогательных классов, например, предикатов.
  Вспомогательные классы, как правило, элементарны и имеют гораздо меньший размер, чем основные.
  
*требование*
#### 2.2.
  Максимальный размер файла - 1000 строк.
  
*рекомендация*
#### 2.3.
  Структура каталогов проекта должна быть построена по следующему принципу:
* assets/ – ресурсы, такие как графика и таблицы стилей и скрипты
  * stylesheets
    *.css, *.less *.scss
  * images/
    *.jpg, *.png, *.svg *etc...*
  * javascripts/
    *.js
* vendor/ - сторонние библиотеки (например bootstrap, foundation, jquery) и шрифты
  * assets/
    * stylesheets/
    * fonts/
      * *.ttf woff *etc...*
    * javascripts/
      * *.js
* bin/ – исполняемые файлы, файлы библиотек и т.п.
* app/ – бизнес-логика приложения. Например для шаблона MVC: 
  * models/
    * *.php
  * controllers/
    * *.php
* \*/*/.php    – собственно страницы (начиная с нулевого уровня вложенности: index.[php/html])
* \*/*/.html
  
*требование*
#### 2.4.
  Все пути, указанные в проекте (Include path, Output Path, …) должны быть относительными.
  
*требование*
#### 2.5.
  Используйте кодировку utf-8
  
*требование*
#### 2.6.
В качестве отступов используйте:

* **html**: **2** пробела
* **css**: **2** пробела
* **js**: **2 или 4** пробела
* **php**: **2 или 4** пробела

"Или" означает что выбрав, скажем, для .js-файлов 4 пробела ВСЕ js-файлы
должны имет такие отступы. Вобщем, для одного типа файлов отступы одинаковые.

**Не используйте табуляцию.**
  
*требование*

#### 2.7.
Убирайте пробелы в конце строк.

*требование*

#### 2.8.
Оставляйте одну пустую строку в конце файла.

*требование*

###  3.  Внутренняя структура файлов
  
#### 3.1.
  Максимальная длина строки в файле - 100 символов. В случае переноса строки используйте вертикальное выравнивание со сдвигом. 
  
*требование*
#### 3.2.
  Все включаемые директивой `include` файлы должны находиться в начале файла.
  
*требование*
#### 3.4.
Включаемые файлы должны быть отсортированы и сгруппированы.
Сортировка производится от низкоуровневых к высокоуровневым файлам.
Для группировки используется одна или несколько пустых строк.

*рекомендация*

###  4.  Именование

#### 4.1.
Имя файла должно быть осмысленным и отражать его назначение.
  
*требование*
#### 4.2.
Для формирования идентификаторов используется английский язык с корректным написанием слов.
  
*требование*
#### 4.3.
Использование собственных аббревиатур в идентификаторах и сокращений сводится к минимуму.
Использование общепринятых аббревиатур допускается.
  
*требование*
#### 4.4.
Избегайте именования локальных объектов таким образом, что они перекрывают внешние имена
  
*требование*
#### 4.5.
Избегайте имен, незначительно отличающихся друг от друга и имен,
использующих похожие символы, такие как '0', '1' и 'O', 'l'.
  
*требование*
#### 4.6.
Имена локальных переменных должны быть короткими и понятными.
Не стоит назвать переменную ThisVariableIsATemporaryCounter,
когда можно просто писать tmp, что не менее понятно.
Переменную счетчика цикла стоит назвать i, а не loop_counter
  
*требование*
#### 4.7.
Название всех идентификаторов должно быть осмысленным.
  
*требование*
#### 4.8.
  При именовании классов и их методов старайтесь выбирать имена таким образом, чтобы вызов вида:
`myObject.method()` читался как имеющая смысл фраза.
  
*рекомендация*
#### 4.9.
Каждое слово, входящее в состав идентификатора, кроме первого,
пишется с заглавной буквы. Слова пишутся слитно, например:
helloWorld
Классы именуются с заглавной буквы, объекты классов, методы и атрибуты — со строчной буквы.
Имена макросов и констант состоят из заглавных букв.
  
*рекомендация*
#### 4.10.
Использование символа `_` для разделения слов в идентификаторах не допускается
  
*требование*
#### 4.11.
Имя функции должно содержать ключевое слово – глагол, имя класса – существительное.
  
*требование*
###  5. Классы

#### 5.1.
Перегруженные функции должны выполнять похожую работу.
Если функции делают разные вещи, они должны иметь разные имена.
  
*требование*
#### 5.2.
Все члены-данные класса должны быть проинициализированы в конструкторе.
  
*требование*
#### 5.3.
Для каждого класса должны быть объявлены:

* деструктор (должен быть виртуальным),
* конструктор по умолчанию,
* оператор присваивания,
* конструктор копий.
  
*рекомендация*
#### 5.4.
Не используйте публичные члены-данные. Избегайте защищенных.
Исключение составляют структуры, не имеющие методов вообще.
  
*рекомендация*
#### 5.5.
Не следует использовать "атрибут типа", т.е. атрибут класса, определяющий его поведение.
Используйте наследование.
  
*рекомендация*

### 6. Функции и методы
  

#### 6.1.
Процедура должна умещаться на двух экранах кода (не более 50 строк).
Рекомендуется ограничиваться 25-ю строками.
  
*требование*
#### 6.2.
Максимально ограничивайте область видимости функции. 
  
*рекомендация*
#### 6.3.
**Функция должна быть короткой и делать ровно одно дело и делать его хорошо.**
  
*рекомендация*
#### 6.4.
В общем случае избегайте создания многоцелевых процедур,
  которые выполняют набор несвязанных между собой действий.
  
*рекомендация*
#### 6.5.
Используйте функцию для одной и только одной цели. 
  
*рекомендация*
#### 6.6.
Краткое описание функциям следует писать ДО написания кода.
  
*рекомендация*

###  7. Переменные
  

#### 7.1.
Переменная должна объявляться как можно ближе к месту, где она будет впервые использована.
  
*требование*
#### 7.2.
Не забывайте инициализировать переменные при объявлении.
  
*требование*
#### 7.3.
В качестве счетчиков циклов допускаются локальные однобуквенные переменные.
Предпочитайте именовать их в такой последовательности: i, j, k, m, n.
  
*требование*
#### 7.4.
Максимально ограничивайте область видимости переменной. Не используйте глобальные переменные. 
Избегайте именования локальных объектов таким образом, что они перекрывают внешние имена
  
*рекомендация*
#### 7.5.
Введение в программу глобальной переменной очень ответственная операция, необходимость которой должна быть четко обоснована. Идентификатор глобальной переменной должен четко сообщать о том, для чего она предназначена.
Перед описанием переменной должен быть комментарий, говорящий о том, что эта переменная содержит и какими частями программы используется. В случае если возникает необходимость работы с переменной из нескольких потоков необходимо обязательно написать в комментарии, какие механизмы применяются для блокировки данной переменной.
Вообще глобальные переменные надо вводить в программу с большой осторожностью, только в том случае, если нельзя без них обойтись или в случае, если решение проблемы другим путем сильно скажется на производительности. 
  
*требование*
#### 7.6.
Используйте переменную для одной и только одной цели. Если временная переменная используется для двух разных целей, заведите две временные переменные
  
*рекомендация*
  

### 8. Синтаксис
  

#### 8.1.
Выражения должны быть как можно более простыми и понятными.
Помните, что код читают люди разной квалификации. Старайтесь облегчить им работу.
  
*требование*
#### 8.2.
  Следует придерживаться следующего правила расстановки {}:
```php
  while (condition) {
    ...
  }


  if (condition) {
    ...
  } else {
    ...
  }

  do {
    ...
  } while (condition)
```

  
*требование*
#### 8.3.
  Перенос длинных строк должен осуществляться после , ; и других операторов
  
*рекомендация*
#### 8.4.
  Операторы сравнения должны быть окружены пробелами
```c++
if (a <= b)
```

  
*рекомендация*
#### 8.5.
  Символы математических операций должны быть окружены пробелами
  
*рекомендация*

#### 8.6.

Пишите теги HTML в нижнем регистре.

```html
<BODY> <-- Нет -->
  <DIV> <-- Нет -->
  </div> <-- Вот так -->
</body> <-- Вот так -->
```

*требование*
#### 8.7.

Закрывайте HTML-теги.

*требование*

#### 8.9.
Используйте HTML так, как это было задумано.

Используйте элементы по назначению:
заголовки для заголовков, p для абзацев, a для ссылок и т.д.

Это облегчает чтение, редактирование и поддержку кода.

*рекомендация*

#### 8.10.

Вложенность в HTML и CSS показывайте отступами.

В разумных пределах. Например, `<a>` внутри `<li>` читается хорошо,
  однако `<li>` внутри `<ul>`, `<header>` внутри `<body>` и тому подобное
  рекомендуется отступать.

```html
  <ul>
    <li> <a href="example.com/recomendations"> Recommendations </a> </li>
    <li> <a href="example.com/comments"> Comments </a> </li>
  </ul>
```

```html
<table>
  <thead>
    <tr>
      <th scope="col">Прибыль</th>
      <th scope="col">Налоги</th>
  </thead>
  <tbody>
    <tr>
      <td>$ 5.00</td>
      <td>$ 4.50</td>
    </tr>
  </tbody>
</table>
```

```css
body{
  background: #ccf;
}
```

*рекомендация*

#### 8.11.

Отделяйте правила CSS друг от друга пустой строкой.

Группируйте правила, например по семантической близости (заголовок, тело, подвал).

*рекомендация*

### 9. Комментирование кода

#### 9.1.
  Каждый файл имеет комментарий, размещаемый в самом начале файла, за которым идет все остальное.
  
*требование*
#### 9.2.
  Комментарии учитывают требования системы генерации документации по исходному тексту doxygen (см. прил. 3)
  
*рекомендация*
#### 9.3.
  Каждый тип данных пользователя (класс, структура, объединение и т.п.), а также каждый элемент класса структуры и т. п. должен быть снабжен комментарием, например:
```c++
//! The SMyOwnClass is created for the special purpose
//! And should be used everywhere it is possible
//! With no obligation to send a post card
class SMyOwnClass
{
    . . .
};
```
  
*требование*
#### 9.4.
  Каждая функция (метод класса) должна быть снабжена комментарием (см. П3.4)
  
*требование*
#### 9.5.
  После того как код написан или изменен, не забудьте просмотреть комментарии к измененной функции или классу и при необходимости обновить их. При изменении функций (методов) следует просматривать комментарии «снизу вверх» - комментарий к самой функции, к вызывающим ее функциям, комментарий к ее классу
  
*требование*
#### 9.6.
  Каждая переменная должна быть прокомментирована. В комментарии указывают назначение переменной и особенности ее использования.
  
*требование*
  
### Приложение 1. Правила оформления комментариев для системы Doxygen


#### 1.1. Тэги которыми желательно пользоваться при оформлении комментариев

Тэг      | Описание
---      | ---
\file    | обозначает начало файла. Может содержать имя файла;
\brief   | краткое описание. Эквивалентно ‘///’;
\author  | автор;
\version | версия файла;
\date    | дата последнего обновления;
\par     | название нового параграфа;
\n       | переход на новую строку;
\fn      | функция (содержит имя функции с параметрами);
\param   | параметр функции (следующие слово за тэгом будет выделено);
\return  | возвращаемое значение;
\note    | описание функции (заметки);
\remarks | примечания, особенности реализации;
\code    | начало блока комментариев, которое выведется фиксированным шрифтом (блок должен заканчиваться тэгом \endcode).

Комментарии для подробного описания с использованием тэгов, должны быть следующего вида:

```c++
/**   
    текст
*/
```

или 

```c++
/*! 
    текст
*/
```
Для краткого описания используется следующий формат:
```c++
/// текст
```

#### Пример:
```c++
/*______________________________ MultPort.cc ________________________________ */
/**
    \file       Multport.cc
    \brief      Реализация мультиплексирующего класса на различные типы пакетов.
    \author     Горбачевский К.С.
    \version    1.2
    \date       10.11.2004
    \note       Класс реализует информационный обмен по протоколу межмодульного
                обмена. Поддерживаются как передача данных в соответствующий
                канал, так и передача команд.
    \remarks    Необходимо создать экземпляр класса, а затем в потоке вызвать
                функцию Create() для инициализации внутренних полей класса.
    \par        История создания:
    \code   
        1/10/2002 – 1.0 – работа по опросу;
        5/05/2003 – 1.1 – используются прерывания для приема и передачи данных;
        7/02/2004 – 1.2 – реализован класс для предоставления сервиса
                          межмодульного взаимодействия.
    \endcode
      
*/
```


#### 1.2. Маркировкa комментариев
Используется комбинация символов `//!`, `/*! . . . */` и `//!<`.
Последний означает, что комментарий относится к предшествующему элементу.
Кроме того, используются комбинации `@param` для описания параметров функций и методов и
`@return` для описания возвращаемых значений.
Комментарии даются на корректном русском языке 
Размер комментария пропорционален сложности комментируемого объекта 
Предпочтительный формат комментария в стиле C++: // 
Комментарии, предшествующие комментируемому элементу, располагаются с отступом 2 пробела 
```c++
  //! This is the remark
bool    SomeBooleanValue;
```


```c++
  //! This is the first line
  //! More detailed description
bool    SomeBooleanValue;
```
  

#### 1.3. Комментарии
  находящиеся в той же строке, что и комментируемый элемент.
Комментарии могут даваться разными способами: предшествующие комментируемому элементу,
  Комментарий, находящийся в той же строке должен быть отделен не менее чем двумя пробелами
  от комментируемого элемента. 
```php
    //! This is the first type of the remark
    bool    SomeBooleanValue;
```

```c++
bool    SomeBooleanValue;    //!< Many lines remark
                             //!< Second line of the remark
```
  

#### 1.4. Описание функций
1. Краткое описание (назначение)
2. Описание параметров, возможные значения, признак входных/выходных параметров ( признак входных/выходных параметров указывается после ‘–’ в скобках: (in) или (out))
3. Возвращаемое значение
4. Комментарии (подробное описание работы функции)
```c++
    //! The function transforms string representation into integer
    //! @param InputValue is a stringed value
    //! @param Base is a scale of notation
    //! @return transformed value of the given scale of notation
long SuperFunction ( const string &  InputValue, long  Base );
  /**
      \fn         int * SpsThreadWrite( void * p )
      \brief      Поток отложенной записи.
      \param      P – указатель на структуру THR_WRITE_PARAMS.
      \return     Указатель на данные.
      \note       Поток инициализирует переменные, ...
      \remarks    Функция не проверяет указатель на NULL.    
*/
void * SpsThreadWrite( void * p )
{
} // SpsThreadWrite
```
